{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs Of Fastopic","title":"Home"},{"location":"#welcome-to-mkdocs-of-fastopic","text":"","title":"Welcome to MkDocs Of Fastopic"},{"location":"databases/","text":"mongodb label minikube node : kubectl label nodes minikube size=large cd manifests/mongodb create stotage class : kubectl apply -f storage-class.yaml create secrets (username and password of database): kubectl apply -f secrets.yaml create pv and pvc with nfs : create the shared folder : sudo mkdir -p /srv/nfsshare Assign server access to client(s) through NFS export file: sudo nano /etc/exports add this rule /srv/nfsshare *(rw,sync,no_subtree_check,no_root_squash,insecure) exportfs -ra enable a firewall for minikube to acess nfs : sudo ufw allow from <minikube_ip> to any port nfs to mount the shared folder to a folder in minikube cluster : mount -t nfs <nfs_adress_ip>:/srv/nfsshare /mnt to unmount a directory : sudo umount sharedfolder_client pv && pvc: kubectl apply -f persistent-volumes.yaml kubectl apply -f persistent-volumes.yaml if you need a mongo client to populate the database: kubectl apply -f mongodb-client.yaml check file mongo-init.js to find the command to add a user. neo4j helm repo add neo4j https://helm.neo4j.com/neo4j helm repo update After creating value.yaml with all configurations needed: cd manifests/neo4j helm install <my-neo4j-release> neo4j/neo4j-standalone -f value.yaml verify : kubectl get statefulsets kubectl exec my-neo4j-release-0 -- tail -n50 /logs/neo4j.log load dumps into the second database: create a pod like done before Put the Neo4j instance in offline mode ensure that offlineMaintenanceModeEnabled: true is added to your file yaml to the neo4j object install with helm copy dumps file into the pod kubectl cp neo4j.dump <pod_name>:neo4j.dump kubectl cp system.dump <pod_name>:system.dump go inside the pod kubectl exec -it <pod_name> /bin/bash load neo4j-admin load --expand-commands --database=neo4j --from neo4j.dump neo4j-admin load --expand-commands --database=system --from system.dump put the Neo4j DBMS in online mode ensure that offlineMaintenanceModeEnabled: false is added to your file .yaml to the neo4j object upgrade with helm helm upgrade <my-neo4j-release> neo4j/neo4j-standalone -f value-wiki.yaml","title":"databases"},{"location":"databases/#mongodb","text":"label minikube node : kubectl label nodes minikube size=large cd manifests/mongodb create stotage class : kubectl apply -f storage-class.yaml create secrets (username and password of database): kubectl apply -f secrets.yaml create pv and pvc with nfs : create the shared folder : sudo mkdir -p /srv/nfsshare Assign server access to client(s) through NFS export file: sudo nano /etc/exports add this rule /srv/nfsshare *(rw,sync,no_subtree_check,no_root_squash,insecure) exportfs -ra enable a firewall for minikube to acess nfs : sudo ufw allow from <minikube_ip> to any port nfs to mount the shared folder to a folder in minikube cluster : mount -t nfs <nfs_adress_ip>:/srv/nfsshare /mnt to unmount a directory : sudo umount sharedfolder_client pv && pvc: kubectl apply -f persistent-volumes.yaml kubectl apply -f persistent-volumes.yaml if you need a mongo client to populate the database: kubectl apply -f mongodb-client.yaml check file mongo-init.js to find the command to add a user.","title":"mongodb"},{"location":"databases/#neo4j","text":"helm repo add neo4j https://helm.neo4j.com/neo4j helm repo update After creating value.yaml with all configurations needed: cd manifests/neo4j helm install <my-neo4j-release> neo4j/neo4j-standalone -f value.yaml verify : kubectl get statefulsets kubectl exec my-neo4j-release-0 -- tail -n50 /logs/neo4j.log load dumps into the second database: create a pod like done before Put the Neo4j instance in offline mode ensure that offlineMaintenanceModeEnabled: true is added to your file yaml to the neo4j object install with helm copy dumps file into the pod kubectl cp neo4j.dump <pod_name>:neo4j.dump kubectl cp system.dump <pod_name>:system.dump go inside the pod kubectl exec -it <pod_name> /bin/bash load neo4j-admin load --expand-commands --database=neo4j --from neo4j.dump neo4j-admin load --expand-commands --database=system --from system.dump put the Neo4j DBMS in online mode ensure that offlineMaintenanceModeEnabled: false is added to your file .yaml to the neo4j object upgrade with helm helm upgrade <my-neo4j-release> neo4j/neo4j-standalone -f value-wiki.yaml","title":"neo4j"},{"location":"gateway/","text":"create the gateway cd manifests/gateway kubectl apply -f http-gateway.yaml configure rules cd manifests/gateway kubectl apply -f virtualservice-external.yaml jwt in istio cd manifests/backend kubectl apply -f jwks.yaml","title":"gateway"},{"location":"gateway/#create-the-gateway","text":"cd manifests/gateway kubectl apply -f http-gateway.yaml","title":"create the gateway"},{"location":"gateway/#configure-rules","text":"cd manifests/gateway kubectl apply -f virtualservice-external.yaml","title":"configure rules"},{"location":"gateway/#jwt-in-istio","text":"cd manifests/backend kubectl apply -f jwks.yaml","title":"jwt in istio"},{"location":"microservices/","text":"microservices for each src directory (frontend and all directories in backend ) don't forget to build images, tag them and push them to your own dokcer hub : move to the directory you want build the new image: docker build -t <image_name> . tag the new image: docker tag <image_name>:latest <docker_hub_repository>/<image_name> push your image: docker push <docker_hub_repository>/<image_name> modify in file deployment with the new image create or modify services and deployment for our microservices : cd manifests/backend for backend kubectl apply -f deployment.yaml for frontend kubectl apply -f frontend-deployment.yaml","title":"microservices"},{"location":"microservices/#microservices","text":"for each src directory (frontend and all directories in backend ) don't forget to build images, tag them and push them to your own dokcer hub : move to the directory you want build the new image: docker build -t <image_name> . tag the new image: docker tag <image_name>:latest <docker_hub_repository>/<image_name> push your image: docker push <docker_hub_repository>/<image_name> modify in file deployment with the new image create or modify services and deployment for our microservices : cd manifests/backend for backend kubectl apply -f deployment.yaml for frontend kubectl apply -f frontend-deployment.yaml","title":"microservices"},{"location":"msgBus/","text":"rabbitmq helm repo add stable https://charts.helm.sh/stable helm repo update helm install mu-rabbit stable/rabbitmq to acess rabbitmq ui: kubectl port-forward svc/mu-rabbit-rabbitmq 15672:15672 to get credentials for rabbimq ui: username :user && password : kubectl get secret mu-rabbit-rabbitmq -o jsonpath=\"{.data.rabbitmq-password}\" | base64 --decode","title":"messageBus"},{"location":"msgBus/#rabbitmq","text":"helm repo add stable https://charts.helm.sh/stable helm repo update helm install mu-rabbit stable/rabbitmq to acess rabbitmq ui: kubectl port-forward svc/mu-rabbit-rabbitmq 15672:15672 to get credentials for rabbimq ui: username :user && password : kubectl get secret mu-rabbit-rabbitmq -o jsonpath=\"{.data.rabbitmq-password}\" | base64 --decode","title":"rabbitmq"},{"location":"userGuide/","text":"Guide to Get started minikube start minikube: minikube start --cpus=4 --memory=16384 istio configure istio: cd istio-1.14.1/ export PATH=$PWD/bin:$PATH istioctl install --set profile=demo -y kubectl label namespace default istio-injection=enabled make sure you have all istio elements running: kubectl get all -n istio-system configure metallb (to get external ip) minikube addons enable metallb set the ip range from 192.168.49.20 to 192.168.49.30 minikube addons configure metallb","title":"userGuide"},{"location":"userGuide/#guide-to-get-started","text":"","title":"Guide to Get started"},{"location":"userGuide/#minikube","text":"start minikube: minikube start --cpus=4 --memory=16384","title":"minikube"},{"location":"userGuide/#istio","text":"configure istio: cd istio-1.14.1/ export PATH=$PWD/bin:$PATH istioctl install --set profile=demo -y kubectl label namespace default istio-injection=enabled make sure you have all istio elements running: kubectl get all -n istio-system","title":"istio"},{"location":"userGuide/#configure-metallb-to-get-external-ip","text":"minikube addons enable metallb set the ip range from 192.168.49.20 to 192.168.49.30 minikube addons configure metallb","title":"configure metallb (to get external ip)"}]}